---
layout: post
---

## temp file

generate temp file name
``` bash
#include <stdio.h>

char *tmpnam(char *s);
	=> s: temp file reference name. If it is non-null, generated temp file name will replace s. The size of s has limitation L_tmpnam(defined in stdio.h). If it is null, the generated temp file name will be put in a system generated array and return
	=> RETURN: if s is non-null, returned pointer will be original s. If s is null, returned pointer will be generated temp file name. Return null if error

	=> this function call has limitation TMP_MAX(defined in stdio.h)

#include <stdlib.h>
char *mktemp(char *template);
	=> template: temp file reference name. The last six characters must be X to replace by unique file name generated by system
	=> RETURN: genereated temp file name. Return null if failed
```

generate temp file name and open as a file
``` bash
#include <stdio.h>

FILE *tmpfile(void);
	=> RETURN: FILE pointer points to temp file created in /tmp. Return null if error

#include <stdlib.h>
int mkstemp(char *template);
	=> template: temp file reference name. The last six characters must be X to replace by unique file name generated by system
	=> RETURN: file descriptor of the generated temp file name file
```

**`Recommend to use tmpfile() and mkstemp() instead of tmpnam() and mktemp() becuase these functions will create temp file and open it at the same time`**

## get user information

get uid and user name
- UID is type uid_t, defined in sys/types.h. It is a positive integer
- Normally, uid is a positive integer bigger than 100
``` bash
#include <sys/types.h>
#include <unistd.h>

uid_t getuid(void);
	=> RETURN: user's uid
char *getlogin(void);
	=> RETURN: user's username
```

get user information structure
``` bash
#include <sys/types.h>
#include <pwd.h>

struct passwd *getpwuid(uid_t uid);
	=> uid: user's uid wants to get struct passwd
	=> RETURN: struct passwd contains user information
		strcut passwd {
			char *pw_name;(user login name)
			uid_t pw_uid;(user uid)
			gid_t pw_gid;(user gid)
			char *pw_dir;(user home directory)
			char *pw_gecos;(user full name)
			char *pw_shell;(user default shell)
		};
struct passwd *getpwnam(const char *name);
	=> name: user's login name wnats to get struct passwd
	=> RETUNR: struct passwd contains user information
```

function to scan struct passwd information
``` bash
#include <pwd.h>
#include <sys/types.h>

void endpwent(void);
	=> free strcut passwd returned form getpwent
struct passwd *getpwent(void);
	=> RETURN: sequencially get each user\'s struct passwd. Return null if is already finished the last user. Or return null if error and set errno
void setpwent(void);
	=> move strcut passwd pointer points by getpwent function to the first user in list
```

## host information

get network information
``` bash
#include <unistd.h>

int gethostname(char *name, size_t namelen);
	=> name: place to store host network name information
	=> namelen: length of name
	=> RETURN: 0 if success, -1 if failed
```

get host information
``` bash
#include <sys/utsname.h>

int uname(struct utsname *name);
	=> name: place to store host information
		struct utsname {
			char sysname[];(operating system name)
			char nodename[];(host name)
			char release[];(system release time)
			char version[];(system version information)
			char machine[];(hardware type)
		};
	=> RETURN: positive number if success, -1 if failed
```

`deprecated, 32-bit is too small`
get unique identifier of current host
``` bash
#include <unistd.h>

long gethostid(void);
	=> RETURN: unique 32-bit identifier of current host
```

## logging

write message to the system message logger
``` bash
#include <syslog.h>

void syslog(int priority, const cahr *message, arguments ...);
	=> priority: log priority. severity level(importantance) OR facility value(device source)
	=> message: log message. format like printf()
	=> argument: arguments for message. Special type "%m" is to show error message of the current errno
```

severity level list:

|level|description|
|-|-|
|LOG_EMERG|emergency condition|
|LOG_ALERT|hight priority condition|
|LOG_CRIT|critical error condition|
|LOG_ERR|error condition|
|LOG_WARNING|warning condition|
|LOG_NOTICE|notice condition|
|LOG_INFO|information condition|
|LOG_DEBUG|debug message condition|

- `LOG_EMERG` will braadcast to every user. `LOG_ALERT` will send to administrators. `LOG_DEBUG` might be ignored. The others message will write to log file

``` bash
#include <syslog.h>

void closelog(void)
	=> close file descriptor opened by openlog()
void openlog(const char *ident, int logopt, int facility);
	=> ident: string prepended to every message
	=> logopt: OR\'ing value in below list to set future syslog behavior
	=> facility: facility value of future syslog. By default, LOG_USER(by random user processes) is used
	
	=> function will open a file descriptor to write message to logging device
int setlogmask(int maskpri);
	=> set priority mask to future syslog(). By default, allows all priorityies to be logged
	=> RETURN: previous log mask level
```

logopt can be:(refer to man for more information)

|name|description|
|-|-|
|LOG_PID|include PID(unique given by system)|
|LOG_CONS|if cannot write to log file, write message to console file(/dev/console)|
|LOG_ODELAY|open log device when syslog() is first called|
|LOG_NDELAY|open log device immediately|
